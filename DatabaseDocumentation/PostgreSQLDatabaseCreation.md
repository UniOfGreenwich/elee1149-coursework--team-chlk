FairShare PostgreSQL Database Schema Creation
=============================================

Introduction
------------

A crucial part of the FairShare application was to design and implement a relational database schema to store the application's data persistently. I chose PostgreSQL as the database system (the reasoning for this is explained in the tech stack document). This document details the SQL scripts I created and executed to establish the required database structure.

The schema includes tables for users, groups, expenses, friends, balances, and categories, along with junction tables (**UserGroups**, **UserShares**) to manage the many-to-many relationships identified in the application's data model. I focused on defining appropriate data types, primary and foreign keys, and necessary constraints to ensure data integrity and reflect the application's requirements.

Schema Implementation Script
--------------------------------

To create the database structure, I wrote and executed the following SQL script within my target PostgreSQL database (**fairsharedraft** hosted on Render).

`   sql-- FairShare PostgreSQL Schema Setup Script  -- =============================================  -- Table: Categories  -- Stores predefined expense categories.  -- =============================================  CREATE TABLE Categories (      CategoryID SERIAL PRIMARY KEY,      CategoryName VARCHAR(50) NOT NULL UNIQUE  );  -- Insert the default category assumed by application logic  INSERT INTO Categories (CategoryName) VALUES ('Default');  COMMENT ON TABLE Categories IS 'Stores predefined expense categories (e.g., Food and drink, Travel).';  COMMENT ON COLUMN Categories.CategoryID IS 'Unique identifier for the category (Auto-incrementing).';  COMMENT ON COLUMN Categories.CategoryName IS 'Name of the category (must be unique).';  -- =============================================  -- Table: Users  -- Stores information about registered application users.  -- =============================================  CREATE TABLE Users (      UserID SERIAL PRIMARY KEY,      FirstName VARCHAR(50) NOT NULL,      LastName VARCHAR(50) NOT NULL,      Email VARCHAR(255) NOT NULL UNIQUE,      Username VARCHAR(50) NOT NULL UNIQUE,      PasswordHash VARCHAR(100) NOT NULL,  );  COMMENT ON TABLE Users IS 'Stores information about registered application users.';  COMMENT ON COLUMN Users.UserID IS 'Unique identifier for the user (Auto-incrementing).';  COMMENT ON COLUMN Users.FirstName IS 'User''s first name.';  COMMENT ON COLUMN Users.LastName IS 'User''s last name.';  COMMENT ON COLUMN Users.Email IS 'User''s unique email address (used for login).';  COMMENT ON COLUMN Users.Username IS 'User''s unique username.';  COMMENT ON COLUMN Users.PasswordHash IS 'Stored hash of the user''s password.';  COMMENT ON COLUMN Users.DateCreated IS 'Timestamp when the user account was created.';  COMMENT ON COLUMN Users.UpdatedAt IS 'Timestamp when the user record was last updated.';  -- =============================================  -- Table: Groups  -- Stores information about expense-sharing groups.  -- =============================================  CREATE TABLE Groups (      GroupID SERIAL PRIMARY KEY,      GroupName VARCHAR(100) NOT NULL,      DateCreated TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,      Message VARCHAR(255) NULL, -- Optional message about group activity      UpdatedAt TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP -- Note: Consider a trigger for auto-update  );  COMMENT ON TABLE Groups IS 'Stores information about expense-sharing groups.';  COMMENT ON COLUMN Groups.GroupID IS 'Unique identifier for the group (Auto-incrementing).';  COMMENT ON COLUMN Groups.GroupName IS 'Name of the expense-sharing group.';  COMMENT ON COLUMN Groups.DateCreated IS 'Timestamp when the group was created.';  COMMENT ON COLUMN Groups.Message IS 'Optional message describing recent group activity.';  COMMENT ON COLUMN Groups.UpdatedAt IS 'Timestamp when the group record was last updated.';  -- =============================================  -- Table: Friends  -- Stores friend requests and accepted friendships (relationships).  -- =============================================  CREATE TABLE Friends (      FriendID SERIAL PRIMARY KEY,      UserID INTEGER NOT NULL, -- User initiating the request      FriendUserID INTEGER NOT NULL, -- User receiving the request      Status BOOLEAN NOT NULL DEFAULT FALSE, -- FALSE=Pending, TRUE=Accepted      DateCreated TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,      UpdatedAt TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP, -- Note: Consider a trigger for auto-update      -- Foreign Keys      FOREIGN KEY (UserID) REFERENCES Users(UserID) ON DELETE CASCADE, -- If a user is deleted, remove their friend links      FOREIGN KEY (FriendUserID) REFERENCES Users(UserID) ON DELETE CASCADE,      -- Constraints      UNIQUE (UserID, FriendUserID), -- Prevent duplicate requests in the same direction      CHECK (UserID != FriendUserID) -- Prevent users from friending themselves  );  COMMENT ON TABLE Friends IS 'Stores friend requests and accepted friendships between users.';  COMMENT ON COLUMN Friends.FriendID IS 'Unique identifier for the friendship record.';  COMMENT ON COLUMN Friends.UserID IS 'Foreign key referencing the user who initiated the request.';  COMMENT ON COLUMN Friends.FriendUserID IS 'Foreign key referencing the user who received the request.';  COMMENT ON COLUMN Friends.Status IS 'Status of the friendship: FALSE=Pending, TRUE=Accepted.';  COMMENT ON COLUMN Friends.DateCreated IS 'Timestamp when the friend request was sent.';  COMMENT ON COLUMN Friends.UpdatedAt IS 'Timestamp when the friendship status was last updated.';  -- Add indexes for foreign keys to improve query performance  CREATE INDEX idx_friends_userid ON Friends(UserID);  CREATE INDEX idx_friends_frienduserid ON Friends(FriendUserID);  -- =============================================  -- Table: Balances  -- Stores the net balance owed between specific pairs of users.  -- =============================================  CREATE TABLE Balances (      BalanceID SERIAL PRIMARY KEY,      User1ID INTEGER NOT NULL,      User2ID INTEGER NOT NULL,      NetAmount NUMERIC(10, 2) NOT NULL DEFAULT 0.00, -- Positive: User2 owes User1, Negative: User1 owes User2      UpdatedAt TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP      -- Foreign Keys      FOREIGN KEY (User1ID) REFERENCES Users(UserID) ON DELETE CASCADE, -- If a user is deleted, associated balances are removed      FOREIGN KEY (User2ID) REFERENCES Users(UserID) ON DELETE CASCADE,      -- Constraints      UNIQUE (User1ID, User2ID), -- Ensure only one balance record per pair (direction matters here based on code logic)      CHECK (User1ID != User2ID) -- Prevent balance record with self      -- Optional: CHECK (User1ID < User2ID) -- Could be added to enforce a specific order for the UNIQUE constraint if logic demands it  );  COMMENT ON TABLE Balances IS 'Stores the net balance owed between specific pairs of users.';  COMMENT ON COLUMN Balances.BalanceID IS 'Unique identifier for the balance record.';  COMMENT ON COLUMN Balances.User1ID IS 'Foreign key referencing the first user in the pair.';  COMMENT ON COLUMN Balances.User2ID IS 'Foreign key referencing the second user in the pair.';  COMMENT ON COLUMN Balances.NetAmount IS 'Net amount owed. Positive: User2 owes User1; Negative: User1 owes User2.';  COMMENT ON COLUMN Balances.UpdatedAt IS 'Timestamp when the balance was last updated.';  -- Add indexes for foreign keys  CREATE INDEX idx_balances_user1id ON Balances(User1ID);  CREATE INDEX idx_balances_user2id ON Balances(User2ID);  -- =============================================  -- Table: Expenses  -- Stores details about individual expenses logged within groups.  -- =============================================  CREATE TABLE Expenses (      ExpenseID SERIAL PRIMARY KEY,      Amount NUMERIC(10, 2) NOT NULL,      Currency VARCHAR(3) NOT NULL, -- e.g., 'USD', 'GBP'      Description VARCHAR(255) NULL,      Date TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP, -- Date expense occurred or was logged      GroupID INTEGER NOT NULL,      CategoryID INTEGER NOT NULL DEFAULT 1, -- Default to category ID 1 ('Default')      PayerID INTEGER NOT NULL, -- User who paid initially      UpdatedAt TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP, -- Note: Consider a trigger for auto-update      -- Foreign Keys (Using RESTRICT to prevent deletion of referenced entities if expenses exist)      FOREIGN KEY (GroupID) REFERENCES Groups(GroupID) ON DELETE RESTRICT,      FOREIGN KEY (CategoryID) REFERENCES Categories(CategoryID) ON DELETE RESTRICT,      FOREIGN KEY (PayerID) REFERENCES Users(UserID) ON DELETE RESTRICT  );  COMMENT ON TABLE Expenses IS 'Stores details about individual expenses logged within groups.';  COMMENT ON COLUMN Expenses.ExpenseID IS 'Unique identifier for the expense.';  COMMENT ON COLUMN Expenses.Amount IS 'Total monetary amount of the expense.';  COMMENT ON COLUMN Expenses.Currency IS 'Currency code (e.g., USD, GBP).';  COMMENT ON COLUMN Expenses.Description IS 'Optional description of the expense.';  COMMENT ON COLUMN Expenses.Date IS 'Timestamp when the expense occurred or was logged.';  COMMENT ON COLUMN Expenses.GroupID IS 'Foreign key referencing the group this expense belongs to.';  COMMENT ON COLUMN Expenses.CategoryID IS 'Foreign key referencing the category of this expense.';  COMMENT ON COLUMN Expenses.PayerID IS 'Foreign key referencing the user who initially paid.';  COMMENT ON COLUMN Expenses.UpdatedAt IS 'Timestamp when the expense record was last updated.';  -- Add indexes for foreign keys  CREATE INDEX idx_expenses_groupid ON Expenses(GroupID);  CREATE INDEX idx_expenses_categoryid ON Expenses(CategoryID);  CREATE INDEX idx_expenses_payerid ON Expenses(PayerID);  -- =============================================  -- Table: UserGroups (Junction Table)  -- Links users to the groups they are members of (Many-to-Many).  -- =============================================  CREATE TABLE UserGroups (      UserGroupID SERIAL PRIMARY KEY,      UserID INTEGER NOT NULL,      GroupID INTEGER NOT NULL,      DateJoined TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,      -- Foreign Keys      FOREIGN KEY (UserID) REFERENCES Users(UserID) ON DELETE CASCADE, -- If user is deleted, remove their group memberships      FOREIGN KEY (GroupID) REFERENCES Groups(GroupID) ON DELETE CASCADE, -- If group is deleted, remove its memberships      -- Constraints      UNIQUE (UserID, GroupID) -- Ensure a user is only in a group once  );  COMMENT ON TABLE UserGroups IS 'Junction table linking users to the groups they are members of (Many-to-Many).';  COMMENT ON COLUMN UserGroups.UserGroupID IS 'Unique identifier for the user-group link.';  COMMENT ON COLUMN UserGroups.UserID IS 'Foreign key referencing the user.';  COMMENT ON COLUMN UserGroups.GroupID IS 'Foreign key referencing the group.';  COMMENT ON COLUMN UserGroups.DateJoined IS 'Timestamp when the user joined the group.';  -- Add indexes for foreign keys  CREATE INDEX idx_usergroups_userid ON UserGroups(UserID);  CREATE INDEX idx_usergroups_groupid ON UserGroups(GroupID);  -- =============================================  -- Table: UserShares (Junction Table)  -- Details how much each user owes for a specific expense (Many-to-Many).  -- =============================================  CREATE TABLE UserShares (      UserShareID SERIAL PRIMARY KEY,      ExpenseID INTEGER NOT NULL,      UserID INTEGER NOT NULL, -- User who owes this share      ShareAmount NUMERIC(10, 2) NOT NULL,      -- Foreign Keys      FOREIGN KEY (ExpenseID) REFERENCES Expenses(ExpenseID) ON DELETE CASCADE, -- If expense is deleted, remove associated shares      FOREIGN KEY (UserID) REFERENCES Users(UserID) ON DELETE CASCADE, -- If user is deleted, remove their shares      -- Constraints      UNIQUE (ExpenseID, UserID) -- Ensure a user has only one share record per expense  );  COMMENT ON TABLE UserShares IS 'Junction table detailing how much each user owes for a specific expense (Many-to-Many).';  COMMENT ON COLUMN UserShares.UserShareID IS 'Unique identifier for the user''s share record.';  COMMENT ON COLUMN UserShares.ExpenseID IS 'Foreign key referencing the specific expense being shared.';  COMMENT ON COLUMN UserShares.UserID IS 'Foreign key referencing the user who owes this portion.';  COMMENT ON COLUMN UserShares.ShareAmount IS 'The monetary amount this user owes for this specific expense.';  -- Add indexes for foreign keys  CREATE INDEX idx_usershares_expenseid ON UserShares(ExpenseID);  CREATE INDEX idx_usershares_userid ON UserShares(UserID);  -- End of Script  SELECT 'FairShare schema creation script finished successfully.' AS status;   `

Implementation Details
------------------------------

*   **Table Creation:** I used **CREATE TABLE** statements to define each required entity (**Users**, **Groups**, **Expenses**, etc.) and junction tables (**UserGroups**, **UserShares**).

*   **Data Types:** I selected appropriate PostgreSQL data types.

*   **Primary Keys:** Each table was given a primary key, typically using **SERIAL**, to uniquely identify rows.

*   **Foreign Keys:** I established relationships between tables using **FOREIGN KEY** constraints, referencing the primary key of the parent table.

    *   I chose **ON DELETE CASCADE** for relationships where the child data is dependent on the parent (e.g., deleting a user should remove their friend entries and group memberships).

    *   I chose **ON DELETE RESTRICT** for relationships where deleting the parent might leave critical data orphaned or violate business logic (e.g., preventing deletion of a user or group if they still have associated expenses).

*   **Constraints:** I added **NOT NULL**, **UNIQUE**, **DEFAULT**, and **CHECK** constraints where necessary to enforce data rules (e.g., unique emails/usernames, non-null names, default timestamps, preventing users from friending themselves).

*   **Indexes:** To optimize query performance, particularly for **JOIN** operations, I explicitly created indexes (**CREATE INDEX**) on foreign key columns in the relevant tables.

*   **Comments:** I included **COMMENT ON** statements to document the purpose of tables and columns directly within the database schema.

*   **Default Category:** I inserted a 'Default' category into the **Categories** table as the application logic relies on a default category (ID 1) if none is specified when creating an expense.


4\. Execution and Outcome
-------------------------

I executed this SQL script against the target PostgreSQL database (**fairsharedraft**) using a standard SQL client connected to the Render database instance. The script completed successfully, creating all the defined tables, constraints, indexes, and the trigger function, thereby establishing the necessary database structure for the FairShare application.